# Async/Await Best Practices

## Concept
The `async`/`await` pattern in C# leverages the Task Parallel Library (TPL) to write non-blocking code. This is crucial for scalability (web apps) and responsiveness (UI apps).

## Key Principles

### 1. Aspync All the Way Down
If you call an async method, `await` it. Do not block on it.
**Violation**: `.Result` or `.Wait()`
-   **Risk**: Deadlocks (especially in legacy ASP.NET or WPF).
-   **Fix**: Return `Task` or `Task<T>` and let the caller await it.

### 2. Return Task, don't `await` just to return
If your method just forwards a task, you don't need the overhead of the state machine generated by `async`/`await`.
-   **Optimization**: Return the `Task` directly if no further logic is needed after the call.

### 3. `ValueTask` for Performance
For "hot paths" where the result is often available synchronously (e.g., cached), use `ValueTask<T>` to avoid allocating a `Task` object.

## Examples

### Violation (Blocking & Fire-and-Forget)

```csharp
public void Button_Click()
{
    // DEADLOCK RISK!
    // Blocking the UI thread waiting for the background thread,
    // which might need the UI thread context to complete.
    var data = GetDataAsync().Result; 
}

public async void FireAndForget()
{
    // AVOID 'async void' (except event handlers)
    // If this crashes, it will crash the process.
    // The caller cannot catch exceptions.
    throw new Exception("Boom");
}
```

### Solution (Proper Pattern)

```csharp
public async Task Button_Click()
{
    // Non-blocking wait
    var data = await GetDataAsync();
}

public async Task SafeAsync()
{
    // Return Task so caller can handle errors
}
```
